"""Unit tests for MCP server WebSocket transport."""

import pytest
import asyncio
import json
from unittest.mock import Mock, AsyncMock, patch, MagicMock
import aiohttp
from aiohttp import web

from ai_whisperer.mcp.server.transports.websocket import WebSocketServerTransport


class TestWebSocketServerTransport:
    """Test WebSocket server transport."""
    
    @pytest.fixture
    def mock_server(self):
        """Create mock server."""
        server = Mock()
        server.handle_request = AsyncMock()
        return server
        
    @pytest.fixture
    def transport(self, mock_server):
        """Create test transport."""
        return WebSocketServerTransport(mock_server, "localhost", 3001)
        
    def test_transport_initialization(self, transport, mock_server):
        """Test transport initialization."""
        assert transport.server is mock_server
        assert transport.host == "localhost"
        assert transport.port == 3001
        assert transport.app is None
        assert transport.runner is None
        assert transport.site is None
        assert len(transport.websockets) == 0
        
    @pytest.mark.asyncio
    async def test_start_transport(self, transport):
        """Test starting WebSocket server."""
        with patch('aiohttp.web.Application') as mock_app_class, \
             patch('aiohttp.web.AppRunner') as mock_runner_class, \
             patch('aiohttp.web.TCPSite') as mock_site_class:
            
            mock_app = Mock()
            mock_app.router = Mock()
            mock_app_class.return_value = mock_app
            
            mock_runner = AsyncMock()
            mock_runner_class.return_value = mock_runner
            
            mock_site = AsyncMock()
            mock_site_class.return_value = mock_site
            
            await transport.start()
            
            # Verify app was created and route added
            mock_app_class.assert_called_once()
            mock_app.router.add_get.assert_called_once_with('/mcp', transport._handle_websocket)
            
            # Verify runner was created and started
            mock_runner_class.assert_called_once_with(mock_app)
            mock_runner.setup.assert_called_once()
            
            # Verify site was created and started
            mock_site_class.assert_called_once_with(mock_runner, "localhost", 3001)
            mock_site.start.assert_called_once()
            
            assert transport.app is mock_app
            assert transport.runner is mock_runner
            assert transport.site is mock_site
            
    @pytest.mark.asyncio
    async def test_stop_transport(self, transport):
        """Test stopping WebSocket server."""
        # Mock active websockets
        ws1 = AsyncMock()
        ws2 = AsyncMock()
        transport.websockets = {ws1, ws2}
        
        transport.site = AsyncMock()
        transport.runner = AsyncMock()
        
        await transport.stop()
        
        # Verify websockets were closed
        ws1.close.assert_called_once()
        ws2.close.assert_called_once()
        
        # Verify server was stopped
        transport.site.stop.assert_called_once()
        transport.runner.cleanup.assert_called_once()
        
    @pytest.mark.asyncio
    async def test_handle_websocket_text_message(self, transport, mock_server):
        """Test handling text WebSocket messages."""
        # Create mock request and WebSocket
        mock_request = Mock()
        mock_request.remote = "127.0.0.1"
        
        mock_ws = AsyncMock()
        mock_ws.prepare = AsyncMock()
        
        # Mock message
        mock_msg = Mock()
        mock_msg.type = aiohttp.WSMsgType.TEXT
        mock_msg.data = json.dumps({
            "jsonrpc": "2.0",
            "method": "test",
            "params": {},
            "id": 1
        })
        
        # Make the websocket async iterator return one message then stop
        mock_ws.__aiter__.return_value = [mock_msg].__iter__()
        
        # Mock server response
        mock_server.handle_request.return_value = {
            "jsonrpc": "2.0",
            "result": {"success": True},
            "id": 1
        }
        
        with patch('aiohttp.web.WebSocketResponse', return_value=mock_ws):
            result = await transport._handle_websocket(mock_request)
            
            # Verify WebSocket was prepared
            mock_ws.prepare.assert_called_once_with(mock_request)
            
            # Verify request was handled
            mock_server.handle_request.assert_called_once()
            
            # Verify response was sent
            mock_ws.send_json.assert_called_once_with({
                "jsonrpc": "2.0",
                "result": {"success": True},
                "id": 1
            })
            
            # Verify cleanup
            mock_ws.close.assert_called_once()
            
    @pytest.mark.asyncio
    async def test_handle_websocket_invalid_json(self, transport):
        """Test handling invalid JSON in WebSocket message."""
        mock_request = Mock()
        mock_request.remote = "127.0.0.1"
        
        mock_ws = AsyncMock()
        mock_ws.prepare = AsyncMock()
        
        # Invalid JSON message
        mock_msg = Mock()
        mock_msg.type = aiohttp.WSMsgType.TEXT
        mock_msg.data = "invalid json"
        
        mock_ws.__aiter__.return_value = [mock_msg].__iter__()
        
        with patch('aiohttp.web.WebSocketResponse', return_value=mock_ws):
            await transport._handle_websocket(mock_request)
            
            # Should send parse error
            mock_ws.send_json.assert_called_once()
            sent_data = mock_ws.send_json.call_args[0][0]
            assert sent_data["error"]["code"] == -32700
            assert "Parse error" in sent_data["error"]["message"]
            
    @pytest.mark.asyncio
    async def test_handle_websocket_error_message(self, transport):
        """Test handling WebSocket error messages."""
        mock_request = Mock()
        mock_request.remote = "127.0.0.1"
        
        mock_ws = AsyncMock()
        mock_ws.prepare = AsyncMock()
        mock_ws.exception = Mock(return_value=Exception("WebSocket error"))
        
        # Error message
        mock_msg = Mock()
        mock_msg.type = aiohttp.WSMsgType.ERROR
        
        mock_ws.__aiter__.return_value = [mock_msg].__iter__()
        
        with patch('aiohttp.web.WebSocketResponse', return_value=mock_ws):
            # Should handle error gracefully
            await transport._handle_websocket(mock_request)
            
            mock_ws.close.assert_called_once()
            
    @pytest.mark.asyncio
    async def test_websocket_connection_tracking(self, transport):
        """Test WebSocket connection tracking."""
        mock_request = Mock()
        mock_request.remote = "127.0.0.1"
        
        mock_ws = AsyncMock()
        mock_ws.prepare = AsyncMock()
        
        # Empty message list to close immediately
        mock_ws.__aiter__.return_value = [].__iter__()
        
        with patch('aiohttp.web.WebSocketResponse', return_value=mock_ws):
            # Check websocket is added to set
            assert len(transport.websockets) == 0
            
            await transport._handle_websocket(mock_request)
            
            # Should be removed after handling
            assert len(transport.websockets) == 0
            
    @pytest.mark.asyncio
    async def test_multiple_messages(self, transport, mock_server):
        """Test handling multiple messages in sequence."""
        mock_request = Mock()
        mock_request.remote = "127.0.0.1"
        
        mock_ws = AsyncMock()
        mock_ws.prepare = AsyncMock()
        
        # Multiple messages
        messages = []
        for i in range(3):
            msg = Mock()
            msg.type = aiohttp.WSMsgType.TEXT
            msg.data = json.dumps({
                "jsonrpc": "2.0",
                "method": f"test{i}",
                "params": {},
                "id": i
            })
            messages.append(msg)
            
        mock_ws.__aiter__.return_value = messages.__iter__()
        
        # Mock server responses
        mock_server.handle_request.side_effect = [
            {"jsonrpc": "2.0", "result": {"n": i}, "id": i}
            for i in range(3)
        ]
        
        with patch('aiohttp.web.WebSocketResponse', return_value=mock_ws):
            await transport._handle_websocket(mock_request)
            
            # Verify all messages were handled
            assert mock_server.handle_request.call_count == 3
            assert mock_ws.send_json.call_count == 3
            
    @pytest.mark.asyncio
    async def test_exception_in_handler(self, transport, mock_server):
        """Test exception handling in WebSocket handler."""
        mock_request = Mock()
        mock_request.remote = "127.0.0.1"
        
        mock_ws = AsyncMock()
        mock_ws.prepare = AsyncMock()
        
        # Raise exception during iteration
        def raise_error():
            raise RuntimeError("Test error")
            yield  # Make it a generator
            
        mock_ws.__aiter__.side_effect = raise_error
        
        with patch('aiohttp.web.WebSocketResponse', return_value=mock_ws):
            # Should handle exception gracefully
            result = await transport._handle_websocket(mock_request)
            
            # Should still close websocket
            mock_ws.close.assert_called_once()
            assert result is mock_ws