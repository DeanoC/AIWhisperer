
# Agent Inspector Feature Plan


## Overview

We use a **Test-Driven Development (TDD)** methodology for all new features. This means tests are written before or alongside implementation, and all features must be covered by automated tests.

The Agent Inspector feature provides a developer/debugging interface to inspect the context (and other internal state) of each agent in the AIWhisperer system. This is useful for verifying agent behavior, debugging, and future extensibility (e.g., inspecting memory, state, or statistics).

---


## Implementation Plan & Checklist


### 1. Backend: Agent Inspection COMMAND


- [ ] Design and implement a new backend COMMAND: `agent.inspect`
  - [ ] Accepts parameters: `agent_id` (required), `info_type` (optional, default: `context`)
  - [ ] Returns the requested info (context, state, etc.) as JSON
  - [ ] Integrate with `AgentContextManager` to fetch context
  - [ ] Add support for future info types (state, memory, etc.)
  - [ ] Restrict access to dev/debug users if needed
  - [ ] **TDD:** Write tests for the COMMAND before/with implementation
  - [ ] **Test:** Returns correct context for valid agent
  - [ ] **Test:** Handles invalid agent_id gracefully
  - [ ] **Test:** Handles unknown info_type gracefully


### 2. Frontend: Agent Inspector UI


- [ ] Add an "Inspector" tab or toggleable panel/button in the chat UI
- [ ] Allow selection of agent (if multiple agents)
- [ ] Allow selection of info type (context, state, ...)
- [ ] Display the info in a readable format (pretty-printed JSON or message list)
- [ ] Add a refresh/reload button
- [ ] Hide/show toggle for minimal UI impact
- [ ] **TDD:** Write tests for the UI component before/with implementation
- [ ] **Test:** Inspector panel renders and toggles
- [ ] **Test:** Displays context for selected agent
- [ ] **Test:** Handles empty/invalid agent gracefully


### 3. Extensibility


- [ ] Design COMMAND and UI to support additional info types in the future (state, memory, stats, etc.)
- [ ] Document how to add new info types to both backend and frontend

---


## Example Backend COMMAND: `agent.inspect`

```json
{
  "command": "agent.inspect",
  "agent_id": "P",
  "info_type": "context"
}
```

**Response:**

```json
{
  "agent_id": "P",
  "info_type": "context",
  "context": [
    { "role": "system", "content": "..." },
    { "role": "user", "content": "..." }
  ]
}
```

---

## Example Frontend UI (React/TSX pseudocode)

```tsx
<Tab label="Inspector">
  <AgentInspectorPanel />
</Tab>

// AgentInspectorPanel.tsx
const [agentId, setAgentId] = useState(currentAgentId);
const [infoType, setInfoType] = useState("context");
const [data, setData] = useState(null);

useEffect(() => {
  fetch(`/api/command`, { method: "POST", body: JSON.stringify({ command: "agent.inspect", agent_id: agentId, info_type: infoType }) })
    .then(res => res.json()).then(setData);
}, [agentId, infoType]);

return (
  <div>
    <select value={agentId} onChange={e => setAgentId(e.target.value)}>{/* agent options */}</select>
    <select value={infoType} onChange={e => setInfoType(e.target.value)}>
      <option value="context">Context</option>
      {/* future: <option value="state">State</option> */}
    </select>
    <button onClick={/* reload */}>Refresh</button>
    <pre>{JSON.stringify(data, null, 2)}</pre>
  </div>
);
```

---

## Notes

- This feature is primarily for development/debugging and can be hidden or restricted in production.
- The design allows for easy extension to new agent info types as the system evolves.

---

## Contributors

- Plan generated by GitHub Copilot, May 2025
