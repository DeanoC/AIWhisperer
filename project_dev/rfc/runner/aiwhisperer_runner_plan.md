# Plan for AIWhisperer Runner Feature

## 1. Introduction

This document outlines a plan for developing a "runner" feature for the AIWhisperer project. The runner will be responsible for taking a planned feature (generated by AIWhisperer from a user's natural language feature request) and executing it. This involves interacting with AI services (streaming responses), performing document editing (reading, writing, modifying files), and accessing the terminal for command execution. The goal is to automate the implementation of AI-generated plans, reducing manual intervention.

This plan is based on the analysis of the existing AIWhisperer project, its current plan generation capabilities (as seen in the `add_openrouter_backend_features` and `improve_openrouter_list_results` examples), and research into best practices for AI agent runners, document manipulation, secure terminal access, and AI service interaction, keeping in mind the preference for using OpenRouter.

## 2. Core Features of the Runner

The AIWhisperer Runner will require the following core features:

1. **Plan Ingestion and Parsing:**
    * Ability to ingest a plan in JSON format, consistent with AIWhisperer's current output.
    * Parse the JSON plan into an internal representation of tasks, sub-tasks, and actions.

2. **Execution Engine:**
    * Sequentially or concurrently (if applicable and safe) execute tasks defined in the plan.
    * Manage the state of execution for each task (e.g., pending, in-progress, completed, failed).
    * Support for conditional logic or branching if specified in the plan (advanced feature).

3. **AI Service Interaction Module:**
    * Interface with AI services, primarily OpenRouter, to send prompts and receive responses.
    * Support for streaming responses from AI models to provide real-time feedback or allow for iterative processing.
    * Handle API authentication, request formatting, and response parsing.
    * Allow configuration of different models for different types of tasks (leveraging AIWhisperer's existing task-specific model configuration).

4. **Document Manipulation Module:**
    * Read content from existing files (source code, markdown, configuration files, etc.).
    * Write new files or overwrite existing ones.
    * Perform in-place modifications to files, such as inserting, deleting, or replacing text/code blocks based on AI instructions or plan steps.
    * Handle various file formats, primarily text-based (code, JSON, MD).

5. **Terminal Interaction Module:**
    * Execute shell commands in a secure and controlled environment.
    * Capture standard output (stdout) and standard error (stderr) from commands.
    * Provide input to interactive commands if necessary (with safeguards).
    * Manage working directories for command execution.

6. **State Management:**
    * Maintain the overall state of the feature implementation process across multiple steps and tasks.
    * Store intermediate results, file paths, and any context necessary for subsequent steps.
    * Potentially support checkpointing and resuming of plan execution.

7. **Error Handling and Recovery:**
    * Robustly handle errors from AI services, file operations, and terminal commands.
    * Implement retry mechanisms for transient errors.
    * Provide clear error messages and context.
    * Allow for defined recovery strategies or manual intervention prompts if a task fails critically.

8. **Logging and Monitoring:**
    * Detailed logging of all actions performed by the runner (plan steps, AI calls, file operations, terminal commands).
    * Log successes, failures, and any significant events.
    * Provide a way to monitor the progress of plan execution.

9. **Configuration Management:**
    * Utilize AIWhisperer's existing `config.yaml` for API keys, model preferences, and potentially runner-specific settings.

10. **User Interaction/Feedback (Optional but Recommended):**
    * Mechanism to ask for user clarification or confirmation at critical decision points if the AI or plan indicates uncertainty.
    * Report progress and final results to the user.

## 3. Proposed Architecture

The runner can be designed with a modular architecture:

* **Plan Manager:**
  * Responsibilities: Loads, parses, and validates the input plan (JSON from AIWhisperer).
  * Maintains the current state of the plan execution.

* **Execution Controller:**
  * Responsibilities: Orchestrates the execution of tasks based on the parsed plan.
  * Iterates through plan steps, invoking appropriate modules for each action.
  * Manages task dependencies and execution flow.

* **AI Service Interface:**
  * Responsibilities: Handles all communication with AI models (e.g., via OpenRouter).
  * Manages prompt formatting, API calls (including streaming), and response parsing.
  * Abstracts the specifics of the AI provider.

* **File System Interface:**
  * Responsibilities: Performs all file operations (read, write, edit).
  * Ensures safe file access and manipulation.

* **Terminal Interface:**
  * Responsibilities: Executes shell commands and captures their output.
  * Manages the environment for command execution (e.g., working directory, environment variables if needed).
  * Implements security measures to prevent malicious command execution (e.g., sandboxing, command validation, user confirmation for risky operations).

* **State Repository:**
  * Responsibilities: Stores the current state of the execution, intermediate data, and context.
  * Could be in-memory for simple runs or a persistent store for longer, resumable tasks.

* **Logging Service:**
  * Responsibilities: Centralized logging for all modules.
  * Writes logs to console and/or files.

* **Error Handler:**
  * Responsibilities: Manages exceptions and errors from all modules.
  * Implements retry logic and recovery strategies.

**Data Flow:**

1. User provides a JSON plan file to the Runner.
2. **Plan Manager** loads and parses the JSON plan.
3. **Execution Controller** takes the first (or next) task from the Plan Manager.
4. Based on the task type, the Execution Controller calls the appropriate interface:
    * For AI interaction: **AI Service Interface**.
    * For file operations: **File System Interface**.
    * For terminal commands: **Terminal Interface**.
5. Interfaces perform the action and return results/status to the Execution Controller.
6. **Execution Controller** updates the task status in the Plan Manager and potentially stores results in the **State Repository**.
7. **Logging Service** records actions and outcomes from all modules.
8. **Error Handler** catches exceptions and attempts recovery or reports failure.
9. Process repeats until all tasks are completed or a critical failure occurs.

**Communication Protocols:**

* Internal: Python function calls and well-defined data structures between modules.
* External: HTTP/S for AI service APIs. Standard input/output/error streams for terminal commands.

## 4. Detailed Implementation Plan

This section breaks down the development into implementable tasks, grouped by the architectural components.

### 4.1. Plan Manager

* **Task 1.1: Define Plan Schema:**
  * Specify the exact JSON structure for plans the runner will consume. This should align with AIWhisperer's output but may need extensions for runner-specific actions (e.g., command execution details, file editing instructions).
  * Consider fields for: `task_id`, `description`, `type` (e.g., `ai_call`, `file_edit`, `shell_command`), `dependencies`, `input_parameters`, `expected_output`.
* **Task 1.2: Implement Plan Parser:**
  * Write Python code to load and validate the JSON plan file against the defined schema.
  * Convert the plan into an internal object representation.
* **Task 1.3: Implement Plan State Tracker:**
  * Develop logic to track the status of each task (pending, running, success, failed).

### 4.2. Execution Controller

* **Task 2.1: Develop Core Execution Loop:**
  * Create the main loop that iterates through tasks from the Plan Manager.
  * Implement logic for sequential execution and handling task dependencies.
* **Task 2.2: Implement Task Dispatcher:**
  * Based on task `type`, dispatch the task to the correct interface module (AI, File, Terminal).
  * Pass necessary parameters from the plan to the interface modules.

### 4.3. AI Service Interaction Module

* **Task 3.1: Enhance OpenRouter Client (if needed):**
  * Leverage AIWhisperer's existing OpenRouter interaction capabilities.
  * Ensure support for streaming responses if not already robustly implemented.
  * Handle various model parameters and configurations.
* **Task 3.2: Implement Prompt Templating/Formatting:**
  * Mechanism to construct prompts dynamically based on plan instructions and context from the State Repository.
* **Task 3.3: Implement Response Handling:**
  * Parse responses from AI models (text, code, structured data).
  * Handle streamed responses chunk by chunk.

### 4.4. Document Manipulation Module (File System Interface)

* **Task 4.1: Implement File Read Operations:**
  * Functions to read entire files or specific parts.
* **Task 4.2: Implement File Write Operations:**
  * Functions to create new files, overwrite existing files, or append to files.
* **Task 4.3: Implement File Editing Operations:**
  * Develop robust functions for targeted edits: inserting text at specific lines/patterns, replacing sections of text/code, deleting lines/patterns.
  * Consider using libraries for structured file formats if applicable (e.g., for JSON patching, though direct text manipulation might be more general for code).
  * Techniques could involve reading the file, making changes in memory, and writing back, or using stream editing for very large files.

### 4.5. Terminal Interaction Module

* **Task 5.1: Implement Secure Command Execution:**
  * Use Python's `subprocess` module with careful attention to security (e.g., avoid `shell=True` with untrusted input, escape arguments).
  * Define a clear policy for allowed commands or require user confirmation for potentially risky commands.
  * Consider running commands in a sandboxed environment if feasible (e.g., Docker container) for enhanced security, though this adds complexity.
* **Task 5.2: Implement Output Capturing:**
  * Capture stdout and stderr from executed commands.
* **Task 5.3: Implement Working Directory Management:**
  * Allow plans to specify the working directory for commands.

### 4.6. State Repository

* **Task 6.1: Design State Data Structure:**
  * Define how execution state (current task, variables, intermediate results, file paths) will be stored.
* **Task 6.2: Implement In-Memory State Storage:**
  * For initial versions, an in-memory Python dictionary or class instance might suffice.
* **Task 6.3 (Advanced): Implement Persistent State Storage:**
  * For resumable executions, consider saving state to a file (e.g., JSON, SQLite).

### 4.7. Logging Service

* **Task 7.1: Configure Logging Framework:**
  * Use Python's `logging` module.
  * Configure formatters, handlers (console, file).
  * Set appropriate log levels for different messages.
* **Task 7.2: Integrate Logging Calls:**
  * Add logging statements throughout all modules to record actions, inputs, outputs, errors, and progress.

### 4.8. Error Handler

* **Task 8.1: Define Custom Exceptions:**
  * Create specific exception classes for runner-related errors (e.g., `PlanValidationError`, `AIRequestError`, `FileOperationError`, `CommandExecutionError`).
* **Task 8.2: Implement Retry Logic:**
  * For network-related errors (e.g., AI service calls), implement configurable retry mechanisms with backoff.
* **Task 8.3: Implement Failure Reporting:**
  * When tasks fail irrecoverably, log detailed error information and report the failure status.

## 5. Plan Format for the Runner

The runner will expect plans in JSON format, generated by AIWhisperer. The schema should be an evolution of what AIWhisperer currently produces, with added fields to support runner actions. An example snippet:

```json
{
  "plan_id": "feature_xyz_implementation",
  "description": "Plan to implement feature XYZ",
  "tasks": [
    {
      "task_id": "001",
      "description": "Analyze existing module A for integration points.",
      "type": "file_read",
      "parameters": {
        "file_path": "src/module_a.py"
      },
      "outputs": {
        "variable_name": "module_a_content"
      }
    },
    {
      "task_id": "002",
      "description": "Ask AI to suggest changes to module A based on requirements and its content.",
      "type": "ai_call",
      "dependencies": ["001"],
      "parameters": {
        "model": "google/gemini-flash-1.5",
        "prompt_template": "Given the content of module_a.py below:\n```python\n{{module_a_content}}\n```\nAnd the requirement: \"Add a new function foo() that does X.\"\nSuggest the necessary code changes to module_a.py.\nOutput only the modified code block for module_a.py.",
        "stream": true
      },
      "outputs": {
        "variable_name": "suggested_code_changes"
      }
    },
    {
      "task_id": "003",
      "description": "Apply suggested code changes to module_a.py.",
      "type": "file_edit",
      "dependencies": ["002"],
      "parameters": {
        "file_path": "src/module_a.py",
        "edit_action": "replace_content", 
        "content_variable": "suggested_code_changes"
      }
    },
    {
      "task_id": "004",
      "description": "Run unit tests for module A.",
      "type": "shell_command",
      "dependencies": ["003"],
      "parameters": {
        "command": "pytest tests/test_module_a.py",
        "working_directory": ".",
        "capture_output": true
      },
      "outputs": {
        "stdout_variable": "test_stdout",
        "stderr_variable": "test_stderr",
        "exit_code_variable": "test_exit_code"
      }
    }
  ]
}
```

Key considerations for the plan format:

* **Task Types:** Clearly defined types (e.g., `ai_call`, `file_read`, `file_write`, `file_edit`, `shell_command`, `user_prompt`).
* **Parameters:** Specific parameters for each task type.
* **Dependencies:** A way to define task dependencies.
* **Inputs/Outputs:** Mechanism to pass data between tasks (e.g., using variables stored in the State Repository).
* **File Editing Granularity:** For `file_edit`, define how changes are specified (e.g., full content replacement, diff/patch format, specific line operations, search/replace patterns).

## 6. Testing Strategy

* **Unit Tests:** Each module (Plan Manager, Execution Controller, Interfaces) should have comprehensive unit tests.
  * Mock external dependencies (AI services, file system, terminal).
  * Test plan parsing, task dispatching, AI call formatting, file operations, command execution logic, error handling, etc.
* **Integration Tests:** Test the interaction between modules.
  * Test execution of simple plans involving multiple task types.
  * Use mock AI services that return predefined responses.
  * Perform tests on temporary files and directories.
* **End-to-End (E2E) Tests:**
  * Test the runner with complete, realistic plans (potentially those generated by AIWhisperer for simple features).
  * These tests might involve actual (but rate-limited and cost-controlled) calls to AI services (e.g., free-tier or cheap models on OpenRouter).
  * Verify that files are correctly modified and commands are executed as expected.
  * Focus on testing the
