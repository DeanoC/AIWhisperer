# AI Tool Interface Design for AIWhisperer

## 1. Introduction

This document outlines the standard interface design for AI-usable tools within the AIWhisperer project. The goal is to create a consistent, extensible, and well-documented structure that facilitates the integration of various tools for AI models, particularly for use with services like Openrouter.

This design addresses the need for:

- A standardized way to define tools in Python.
- Generation of tool definitions compatible with the Openrouter API.
- Clear instructions for AI models on how and when to use each tool.
- A straightforward mechanism for handling tool inputs and outputs.
- Easy extensibility for future tools.

## 2. Core Interface: The `AITool` Abstract Base Class

All AI tools in AIWhisperer will inherit from an abstract base class (ABC) named `AITool`. This class defines the common structure and methods that every tool must implement.

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, List

class AITool(ABC):
    """
    Abstract base class for all AI-usable tools in the AIWhisperer project.
    """

    @property
    @abstractmethod
    def name(self) -> str:
        """
        A unique, machine-readable identifier for the tool.
        e.g., "read_file", "execute_python_code"
        """
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """
        A concise, human-readable description of what the tool does.
        e.g., "Reads the content of a specified text file."
        """
        pass

    @property
    @abstractmethod
    def parameters_schema(self) -> Dict[str, Any]:
        """
        A JSON schema object defining the input parameters for the tool.
        This schema is used for validation and for generating the Openrouter tool definition.
        Example:
        {
            "type": "object",
            "properties": {
                "path": {
                    "type": "string",
                    "description": "The relative or absolute path to the file to be read."
                },
                "encoding": {
                    "type": "string",
                    "description": "The encoding of the file (e.g., 'utf-8'). Defaults to 'utf-8'.",
                    "default": "utf-8"
                }
            },
            "required": ["path"]
        }
        """
        pass

    @abstractmethod
    def get_openrouter_tool_definition(self) -> Dict[str, Any]:
        """
        Generates the tool definition in a format compatible with the Openrouter API
        (specifically, the OpenAI function calling format).
        """
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": self.parameters_schema
            }
        }

    @abstractmethod
    def get_ai_prompt_instructions(self) -> str:
        """
        Generates clear and concise instructions for the AI model on how and when
        to use the tool, including details about its purpose, parameters,
        and expected output.
        """
        pass

    @abstractmethod
    async def execute(self, **kwargs: Any) -> Any:
        """
        The core logic for the tool's operation.
        It receives parameters as keyword arguments, validated against parameters_schema.
        The method should be asynchronous if it involves I/O operations.

        Args:
            **kwargs: The parameters for the tool, matching the parameters_schema.

        Returns:
            The output of the tool's execution. This can be of any type
            (e.g., string, dictionary, list) relevant to the tool's function.
            The output should be serializable if it needs to be passed back to the AI.
        """
        pass

```

## 3. Openrouter API Tool Definition

The `get_openrouter_tool_definition()` method will generate a dictionary adhering to the OpenAI function calling specification, which is widely supported by models available through Openrouter.

**Example Structure:**

```json
{
  "type": "function",
  "function": {
    "name": "tool_name_here",
    "description": "Tool description here.",
    "parameters": { // JSON schema for parameters
      "type": "object",
      "properties": {
        "param_name": {
          "type": "string", // or number, boolean, array, object
          "description": "Description of the parameter."
        }
        // ... other parameters
      },
      "required": ["param_name_if_required"] // List of required parameter names
    }
  }
}
```

This structure will be automatically generated by the base `AITool` class's implementation of `get_openrouter_tool_definition()` using the tool's `name`, `description`, and `parameters_schema` properties. Concrete tool classes typically won't need to override this method unless a highly specialized format is required.

## 4. AI Prompt Instructions

The `get_ai_prompt_instructions()` method is crucial for guiding the AI model. It should produce a clear, structured text block.

**Recommended Format:**

```text
**Tool: `tool_name_here`**
*   **Description:** A brief explanation of what the tool does.
*   **Purpose:** Clearly explain *when* and *why* the AI should consider using this tool. Provide context or scenarios.
*   **Parameters:**
    *   `param_name_1` (`type`, e.g., string, `required`|`optional`, default: `value_if_any`): Description of the parameter and its constraints.
    *   `param_name_2` (`type`, e.g., integer, `optional`): Description of another parameter.
*   **Expected Output:** Describe the nature and format of what the tool returns (e.g., "The content of the file as a string.", "A JSON object containing weather data.").
*   **Example (for AI to understand usage):**
    If you need to [perform an action related to the tool's purpose], use this tool.
    For example, to [specific example use case]:
    Call: `tool_name_here` with `param_name_1="example_value"`
```

Concrete tool classes must implement this method to provide tailored instructions.

## 5. Tool Input and Output Handling

- **Inputs:**
  - Tool inputs are defined by the `parameters_schema` property.
  - They are passed as keyword arguments to the `execute(**kwargs)` method.
  - It is recommended that the system calling the `execute` method performs validation of the arguments against the `parameters_schema` before execution, though individual tools can also implement internal validation.
- **Outputs:**
  - The `execute(**kwargs)` method returns the result of the tool's operation.
  - The output can be of any Python type. However, if the output needs to be directly presented to the AI model as part of its context or as a result of a tool call, it should ideally be a serializable type (e.g., string, number, boolean, list, or dictionary of serializable types).
  - Complex objects should be converted to a suitable string or dictionary representation.
- **Error Handling:**
  - The `execute` method should handle expected errors gracefully (e.g., file not found for a `read_file` tool) and return a meaningful error message or status. This could be a dictionary like `{"error": "File not found: /path/to/file.txt"}`.
  - Unexpected errors should be allowed to propagate so they can be logged and handled by the calling system.

## 6. Extensibility

Adding new tools is designed to be straightforward:

1. Create a new Python class that inherits from `AITool`.
2. Implement the abstract properties: `name`, `description`, and `parameters_schema`.
3. Implement the abstract methods: `get_ai_prompt_instructions()` and `execute(**kwargs)`.
4. The `get_openrouter_tool_definition()` method can usually be inherited directly from the base class.

This approach ensures that all tools adhere to a common interface, simplifying their integration and management within AIWhisperer.

## 7. Tool Management and Compilation

While not part of the individual tool interface itself, the system will require a mechanism (e.g., a `ToolRegistry` class or utility functions) to:

- Discover and register available `AITool` implementations.
- Compile lists of tool definitions for the Openrouter API based on context or configuration (e.g., all tools, a subset of tools).
- Compile aggregated AI prompt instructions for the selected tools.

This registry would iterate over registered tool instances, calling `get_openrouter_tool_definition()` and `get_ai_prompt_instructions()` as needed.

## 8. Example: `ReadFileTool`

Here's a conceptual example of a `ReadFileTool`:

```python
import os
from typing import Dict, Any

# Assuming AITool is defined as above in a shared module
# from aiwhisperer.tools.base import AITool

class ReadFileTool(AITool):
    @property
    def name(self) -> str:
        return "read_file"

    @property
    def description(self) -> str:
        return "Reads the entire content of a specified text file."

    @property
    def parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "path": {
                    "type": "string",
                    "description": "The relative or absolute path to the file to be read."
                },
                "encoding": {
                    "type": "string",
                    "description": "The encoding of the file (e.g., 'utf-8'). Defaults to 'utf-8'.",
                    "default": "utf-8"
                }
            },
            "required": ["path"]
        }

    def get_ai_prompt_instructions(self) -> str:
        return """**Tool: `read_file`**
*   **Description:** Reads the entire content of a specified text file.
*   **Purpose:** Use this tool when you need to access the textual content of a file from the local filesystem. This is useful for understanding code, reading documentation, or extracting information from text-based data files.
*   **Parameters:**
    *   `path` (string, required): The relative or absolute path to the file. Ensure the path is correct and accessible.
    *   `encoding` (string, optional, default: 'utf-8'): The character encoding of the file (e.g., 'utf-8', 'ascii').
*   **Expected Output:** A string containing the full content of the file. If the file is not found or cannot be read, an error message will be returned as a string.
*   **Example (for AI to understand usage):**
    If you need to read the content of 'src/main.py':
    Call: `read_file` with `path="src/main.py"`
    If you need to read 'config.txt' with 'ascii' encoding:
    Call: `read_file` with `path="config.txt"`, `encoding="ascii"`"""

    async def execute(self, path: str, encoding: str = "utf-8", **kwargs: Any) -> str:
        """
        Reads the content of the specified file.
        """
        # In a real scenario, consider security implications of arbitrary file access.
        # Path validation/sandboxing might be necessary.
        try:
            # Ensure path is treated as relative to a workspace root if applicable
            # For this example, direct path usage is shown.
            # workspace_root = "/path/to/workspace" # This should be configured
            # full_path = os.path.join(workspace_root, path)
            # if not os.path.abspath(full_path).startswith(os.path.abspath(workspace_root)):
            #     return f'{{"error": "Access denied: Path is outside the allowed workspace."}}'

            with open(path, 'r', encoding=encoding) as f:
                content = f.read()
            return content
        except FileNotFoundError:
            return f'{{"error": "File not found: {path}"}}'
        except UnicodeDecodeError:
            return f'{{"error": "Encoding error: Could not decode file {path} with encoding {encoding}."}}'
        except Exception as e:
            # Log the full error for debugging
            # logger.error(f"Error reading file {path}: {e}")
            return f'{{"error": "An unexpected error occurred while reading file {path}: {str(e)}"}'

    # get_openrouter_tool_definition can be inherited if the base class provides a suitable default.
    # If not, or if customization is needed:
    def get_openrouter_tool_definition(self) -> Dict[str, Any]:
        return super().get_openrouter_tool_definition()

```

## 9. Example: `ExecuteCommandTool`

Here's a conceptual example of an `ExecuteCommandTool`:

```python
import subprocess
import logging
from typing import Dict, Any, Optional

# Assuming AITool is defined as above in a shared module
# from aiwhisperer.tools.base import AITool

logger = logging.getLogger(__name__) # Assuming logger is configured

class ExecuteCommandTool(AITool):
    @property
    def name(self) -> str:
        return "execute_command"

    @property
    def description(self) -> str:
        # Using a more descriptive version for the documentation,
        # aligned with the tool's capabilities.
        return "Executes a system command and returns its standard output, standard error, and return code. Allows specifying a working directory."

    @property
    def parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "command": {
                    "type": "string",
                    "description": "The CLI command to execute (e.g., \"python script.py --arg\", \"ls -l\")."
                },
                "cwd": {
                    "type": "string",
                    "description": "The working directory to execute the command in. Defaults to the AIWhisperer's current workspace directory if not specified.",
                    "default": "." # As per implementation
                }
            },
            "required": ["command"]
        }

    # category and tags can be included as per source if desired for completeness in this example
    # @property
    # def category(self) -> Optional[str]:
    #     return "System"
    #
    # @property
    # def tags(self) -> list[str]:
    #     return ["cli", "command", "execute", "system"]

    def get_ai_prompt_instructions(self) -> str:
        return """**Tool: `execute_command`**
*   **Description:** Executes a CLI command on the system and returns its standard output, standard error, and return code.
*   **Purpose:** Use this tool when you need to run an external program, script, or shell command on the system. This is useful for tasks like compiling code, running scripts (e.g., Python, shell), executing utility commands, or performing automated tasks that involve command-line operations. The command is executed using `shell=True` internally, so shell-specific features like pipes (`|`) or complex redirection (`>>`) within the command string are supported.
*   **Parameters:**
    *   `command` (string, required): The complete command string to execute (e.g., "python my_script.py --arg1 value1", "ls -l /tmp", "grep 'error' logs.txt | wc -l").
    *   `cwd` (string, optional, default: '.'): The working directory from which to execute the command. If not specified, it defaults to the current workspace directory of the AIWhisperer application.
*   **Expected Output:** A dictionary containing:
    *   `stdout` (string): The standard output (stdout) captured from the command.
    *   `stderr` (string): The standard error (stderr) captured from the command.
    *   `returncode` (integer): The exit status code of the command. `0` typically indicates success. Non-zero codes usually indicate an error or specific status.
*   **Example (for AI to understand usage):**
    If you need to list files in the 'src' directory:
    Call: `execute_command` with `command="ls -l src"`
    If you need to run a Python script 'data_processor.py' with an argument, and the script is in a 'scripts' subdirectory:
    Call: `execute_command` with `command="python data_processor.py --input data.csv"`, `cwd="scripts"`
    If you need to find all Python files in the current directory and its subdirectories, then count them:
    Call: `execute_command` with `command="find . -name '*.py' | wc -l"`"""

    async def execute(self, command: str, cwd: str = ".") -> Dict[str, Any]:
        """
        Executes a shell command and returns the output, error, and return code.
        Note: This example uses subprocess.run for simplicity. The actual tool might use asyncio.create_subprocess_exec.
        """
        logger.info(f"Executing command: {command} in directory: {cwd}")
        try:
            # The actual implementation uses shell=True, which is important for how commands are formed.
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                cwd=cwd,
                check=False # Do not raise exception for non-zero exit codes
            )
            logger.info(f"Command execution finished with return code: {result.returncode}")
            return {
                "stdout": result.stdout,
                "stderr": result.stderr,
                "returncode": result.returncode
            }
        except FileNotFoundError:
            logger.error(f"Command not found: {command}")
            return {
                "stdout": "",
                "stderr": f"Error: Command not found: {command}",
                "returncode": 127 # Common return code for command not found
            }
        except Exception as e:
            logger.error(f"Error executing command '{command}': {e}")
            return {
                "stdout": "",
                "stderr": f"Error executing command: {e}",
                "returncode": 1 # Generic error code
            }

    # get_openrouter_tool_definition can be inherited if the base class provides a suitable default.
    def get_openrouter_tool_definition(self) -> Dict[str, Any]:
        return super().get_openrouter_tool_definition()

```

## 10. Conclusion

This interface design provides a robust and flexible foundation for integrating AI tools into AIWhisperer. By adhering to this standard, developers can easily create and add new tools, ensuring consistency in how they are defined, presented to AI models, and executed.
