# Execution Engine Documentation

## Overview

The Execution Engine is a core component responsible for orchestrating and executing tasks defined within a plan. Its primary role is to process a sequence of tasks, manage their execution state, handle dependencies between tasks, and manage errors that occur during execution. It interacts closely with the State Manager to maintain the state of the overall plan and individual tasks.

## Integration with Logging and Monitoring

The Execution Engine's operations are thoroughly logged and can be observed via the AIWhisperer's monitoring interface. This includes the initiation of tasks, state transitions (e.g., from "pending" to "running", "completed", or "failed"), dependency evaluations, and any errors encountered during execution. This detailed logging is crucial for understanding the engine's behavior and for debugging purposes.

For comprehensive information on the logging and monitoring capabilities, refer to the [Logging and Monitoring Documentation](./logging_monitoring.md).

## Key Components

Based on the design and implementation, the key components and concepts are:

* **ExecutionEngine Class**: The main class that encapsulates the execution logic.
* **State Manager**: An external component (injected dependency) responsible for persisting and retrieving the state of tasks and their results.
* **Task Queue**: Internally, the `ExecutionEngine` processes tasks from a list which can be thought of as a queue, executing them in the order provided by the plan.
* **Task Executor (Conceptual)**: While not a distinct class in the current simplified implementation (`_execute_single_task` is a placeholder), the design anticipates a component responsible for the actual logic of executing different types of tasks based on their `agent_spec`.
* **Error Handling**: Mechanisms within the `execute_plan` method to catch exceptions during task execution and update the task state accordingly.

## Processing a Plan (Workflow)

The `ExecutionEngine` processes a plan, which is expected to be a list of task definitions, typically provided by a Plan Parser. The execution flow is as follows:

1. **Initialization**: The `execute_plan` method receives the plan data. It initializes an internal task queue (a list) with the tasks from the plan.
2. **Sequential Execution**: The engine iterates through the tasks in the queue sequentially.
3. **State Initialization**: For each task, its state is initially set to "pending" using the State Manager.
4. **Dependency Check**: Before executing a task, the engine checks if it has any dependencies (`depends_on`). If dependencies exist, it queries the State Manager for the status of each dependent task.
5. **Execution or Skipping**:
    * If a task has no dependencies, or if all its dependencies have a status of "completed", the task's state is updated to "in-progress", and the task execution logic is invoked (currently via the `_execute_single_task` placeholder).
    * If any dependency is not "completed", the task's state is set to "skipped", and the reason is recorded. The engine then moves to the next task without executing the current one.
6. **State and Result Update**: Upon completion of a task (either successfully or with an error), the State Manager is updated with the final state ("completed" or "failed") and any resulting output.
7. **Continuation**: The engine continues this process until all tasks in the plan have been processed.

## Interaction with the State Manager

The Execution Engine relies heavily on the State Manager for persistent state management. It uses the State Manager to:

* Set and update the state of individual tasks (e.g., "pending", "in-progress", "completed", "failed", "skipped").
* Retrieve the status of tasks, particularly for checking dependencies.
* Store the results or output generated by completed tasks.
* Retrieve the results of tasks, which can be used by subsequent tasks (though this is an advanced feature not fully implemented in the placeholder).

The `ExecutionEngine` is initialized with a `state_manager` instance, ensuring this dependency is met.

## Handling Task Dependencies

Task dependencies are specified in the plan using the `depends_on` field, which is a list of `step_id`s of tasks that must be completed before the current task can run. The `execute_plan` method checks these dependencies by querying the State Manager for the status of each dependent task. A task is only executed if all its dependencies have a status of "completed". Otherwise, the task is marked as "skipped".

## Error Handling

The Execution Engine implements basic error handling within the `execute_plan` method. It uses a `try...except` block around the task execution logic (`_execute_single_task`).

* If a `TaskExecutionError` (a custom exception for expected task failures) or any other `Exception` occurs during the execution of a task, the task's state is updated to "failed" using the State Manager, and the error information is recorded.
* Crucially, the engine is designed to continue processing subsequent tasks even if a task fails, allowing for partial plan execution.

## API Documentation

### `class ExecutionEngine`

Executes tasks defined in a plan, managing state and handling dependencies.

#### `__init__(self, state_manager)`

Initializes the `ExecutionEngine`.

* **Parameters**:
  * `state_manager`: An object responsible for managing the state of tasks. Expected to have methods like `set_task_state`, `get_task_status`, `store_task_result`, and `get_task_result`.
* **Raises**:
  * `ValueError`: If `state_manager` is `None`.

#### `execute_plan(self, plan_data)`

Executes the given plan sequentially.

* **Parameters**:
  * `plan_data` (`dict`): The plan data, typically from a PlanParser, containing a list of task definitions under the key `"plan"`.
* **Returns**:
  * `None`: The method modifies state via the `state_manager` and does not return a value.

#### `get_task_status(self, task_id)`

Returns the status of a specific task.

* **Parameters**:
  * `task_id` (`str`): The ID of the task.
* **Returns**:
  * `str` or `None`: The status of the task (e.g., "pending", "in-progress", "completed", "failed", "skipped"), or `None` if the task ID is not found in the state manager.

#### `get_task_result(self, task_id)`

Returns the intermediate result of a specific task.

* **Parameters**:
  * `task_id` (`str`): The ID of the task.
* **Returns**:
  * `any` or `None`: The result of the task, or `None` if the task ID is not found, the task is not completed, or the task produced no result.
